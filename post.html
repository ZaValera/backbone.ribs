<h1>Ribs.js - вложенные атрибуты, вычисляемые поля и биндинги для Backbone.js</h1>
<h2>Введение</h2>
Ribs.js - это библиотека, которая раширяет возможности Backbone. И прелесть в том, что именно расширяет, а не изменяет.
Вы можете использовать ваш любимый Backbone, как и прежде, но по необходимости задействовать новые возможности, речь о которых пойдет дальше.
<h2>Вложенные атрибуты</h2>
Начнем с самого простого и очевидного. Если вы много пишете на Backbone, то наверняка сталкивалиьс с проблемой, когда нужно внести изменения в модель, атрибуты которой далеко не плоские.
<source lang="JavaScript">
    var Simpsons = Backbone.Ribs.Model.extend({
        defaults: {
            homer: {
                age: 40,
                weight: 90,
                job: 'Safety Inspector'
            },
            bart: {
                age: 10,
                weight: 30,
                job: '4th grade student'
            }
        }
    });

    var family = new Simpsons();
</source>
Предположим, что Гомер плотно пообедал и набрал пару киллограмов:

Backbone
<source lang="JavaScript">
    var homer = _.clone(family.get('homer'));

    homer.weight = 92;
    family.set('homer', homer);
</source>

Для того, чтобы не нарушать get/set подход, нам необходимо:
- забрать объект из модели
- создать копию этого объекта
- внести необходимые изменения
- положить обратно

Согласитесь, это крайне неудобно. А если учесть тот факт, что объекты могуть быть огромными, то это еще и очень затратно.
Куда проще изменить именно тот атрибут, который нужно:

Backbone + Ribs
<source lang="JavaScript">
    family.set('homer.weight', 92);
</source>

Какие именно события будут сгенерированы, можно прочитать в <a href="https://github.com/ZaValera/backbone.ribs/wiki/Get-и-Set-вложенных-атрибутов-модели">документации</a>
<h2>Вычисляемые атрибуты</h2>
Сразу оговорюсь, что я привык называть их вычисляемыми полями, поэтому прошу меня извинить за двойную терминологию.
Итак, приступим.
Очень часто возникает ситуация, когда атрибуты модели нужно преобразовать в определенную форму (назовем ее "результат"), а потом этот результат изпользовать, да еще и не в одном месте.
И хорошо бы, чтобы при изменении атрибутов, результат обновлялся, и всё, что на него завязано, тоже бы обновлялось.
В результате получается достаточно громоздкая вереница из дополнительних метдов и подписок, которую в будущем будет достаточно проблемотично поддерживать.

К примеру, Профессор Фринк задумал некое безумное исследование, в котором ему очень важно контролировать общий вес Гомера и Барта.
Мне не хочется писать вариант на чистом Backbone, к тому же вариантов можно придумать достаточно много.
Давайте сразу рассмотрим вариант с вычисляемыми атрибутами Ribs.
<source lang="JavaScript">
    var Simpsons = Backbone.Ribs.extend({
        defaults: {
            homer: {
                age: 40,
                weight: 90,
                job: 'Safety Inspector'
            },
            bart: {
                age: 10,
                weight: 30,
                job: '4th grade student'
            }
        },
            
        computeds: {
            totalWeight: {
                deps: ['homer.weight', 'bart.weight'],
                get: function (h, b) {
                    return h + b;
                }
            }
        }
    });

    var family = new Simpsons();
</source>
Что же здесь происходит?
Мы добавили вычисляемое поле, которое зависит от двух атрибутов. При изменении какого-либо из атрибутов, вычисляемое поле пересчитается автоматически.
Работая с экземпляром модели, вычисляемые поля можно воспринимать как обычные атрибуты.
Вы можете прочитать его значение:
<source lang="JavaScript">
    family.get('totalWeight'); // 120
</source>
Можете подписаться на его изменение:
<source lang="JavaScript">
    family.on('change:totalWeight', function () {});
</source>
А в случае необходимости, можно описать метод set для вычисляемого поля, и сетить его без зазрения совести.

Также, вычисляемые поля очень удобны в биндингах.
<h2>Биндинги</h2>
Биндинг - это связь между моделью и DOM элементов. Проще тут и не скажешь.
Веб-разработчику изо дня в день приходтся выводить всякие данные в интерфейсе. Следить за их изменениями. Обновлять. Снова выводить... А тут уже и рабочий день закончился.
Вернемся к нашим желтым друзьям. Захотелось нам выводить суммарный вес на какое-нибудь табло.

Что бы мы делали в чистом Backbone?
Забыв про вычисляемые поля, мы вернемся к двум атрибутам, от которых мы зависим.
Напишем метод, который будет обновлять текст некого span-a суммарным значением этих атрибутов.
Подпишем этот метод на обработку change:homer и change:bart.
Подумаем, как бы нам игнорировать другие изменения homer и bart, которые не касаются веса.
Согласитесь, достаточно много писанины для очень распространенной ситуации.

Теперь то же самое, но короче и проще:
<source lang="JavaScript">
    var Simpsons = Backbone.Ribs.Model.extend({
        defaults: {
            homer: {
                age: 40,
                weight: 90,
                job: 'Safety Inspector'
            },
            bart: {
                age: 10,
                weight: 30,
                job: '4th grade student'
            }
        },

        computeds: {
            totalWeight: {
                deps: ['homer.weight', 'bart.weight'],
                get: function (h, b) {
                    return h + b;
                }
            }
        }
    });

    var family = new Simpsons();

    var Table = Backbone.Ribs.View.extend({
        bindings: {
            'span': 'text:family.totalWeight'
        },

        initialize: function () {
            this.family = family;
        }
    });

    var table = new Table();
</source>

Теперь, при любых изменениях веса Гомера или Барта, span будет обновлен.
Помимо текста, вы можете создавать и другие связи между параметрами DOM элементов и атрибутами моделей:
- двусторонняя связь с input-ами различных типов (text, checkbox, radio)
- css-атрибута
- css-классы
- модификаторы
- и другое

Помимо обычных биндингов в Ribs.js можно создать биндинг коллекции.
Описание этого механизма заслуживает отдельной статьи, поэтому в рамках данной статьи расскажу в двух словах.
Биндинг коллекции связывает коллекцию моделей, Backbone.View и некий DOM элемент.
Для каждой модели из коллекции создается свой экземпляр View и кладется в DOM элемент.
Причем при любых изменениях коллекции (добавление/удаление моделей, сортировка) интерфейс обновляется без вашего вмешательства.
Тем самым вы получаете динамическое представление для всей коллекции.
Область применения очевидна - разнообразные списки и структуры с однотипными данными.

<h2>Заключение</h2>
В данной статье я попытался познакомить вас с основными идеями и концепциями, заложенными в Ribs.js
Скачать саму библиотеку и ознакомиться с документацией вы можете <a href="https://github.com/ZaValera/backbone.ribs">здесь</a>